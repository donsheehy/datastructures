\chapter{Mappings and Hash Tables}


A \textbf{mapping} is an association between two sets of things.  It associates a value to a key.  We  refer to these associated pairs as \textbf{key-value pairs}.
Keys must be unique, so that there can only be one value associated with a given key.


The standard built-in data type in python for mappings is the dictionary (\texttt{dict}).
This kind of mapping is used by python itself to associate names of variables (strings) with objects.
In the notation for dictionaries, we would write \texttt{d[some\_key] = some\_value}.
This either creates a new key-value pair if \texttt{some\_key} was not already in the dictionary, or it overwrites the existing pair with key \texttt{some\_key}.


Not all programming languages come with a built-in data type for mappings.
We're going to pretend for a short time that we don't have a python dictionary available to us and go through the process of implementing one ourselves.  This will allow us to resolve one of the major unsolved mysteries from earlier in the course:

\begin{quote}

Why does accessing or assigning a value in a dictionary take only constant time?

\end{quote}
\section{The Mapping ADT}


A \textbf{mapping} is a collection of key-value pairs such that the keys are unique (i.e. no two pairs have the same key).
It supports the following methods.

\begin{itemize}

\item 

\textbf{\texttt{get(k)}} - return the value associate to the key \texttt{k}.  Usually an error (\texttt{KeyError}) is raised if the given key is not present.



\item 

\textbf{\texttt{put(k, v)}} - Add the key-value pair \texttt{(k,v)} to the mapping.



\end{itemize}

These are the two main operations.  They are what make a mapping, and are generally implemented as \texttt{\_\_getitem\_\_} and \texttt{\_\_setitem\_\_} in python in order to support the familiar square bracket notation.  We will put off anything more elaborate for now.  When we get into some implementations, we will put some other conditions on the keys.

\section{A minimal implementation}


Here is a very lightweight method for using a \texttt{list} as a mapping.  We start with a little class to store key-value pairs, then give two methods to implement get and put.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} mapping/mapping.py}

\PY{k}{class} \PY{n+nc}{Entry}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{key} \PY{o}{=} \PY{n}{key}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{value} \PY{o}{=} \PY{n}{value}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb}{str}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{key}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ : }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{value}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{mapput}\PY{p}{(}\PY{n}{L}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n}{L}\PY{p}{:}
        \PY{k}{if} \PY{n}{e}\PY{o}{.}\PY{n}{key} \PY{o}{==} \PY{n}{key}\PY{p}{:}
            \PY{n}{e}\PY{o}{.}\PY{n}{value} \PY{o}{=} \PY{n}{value}
            \PY{k}{return}
    \PY{n}{L}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{Entry}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{mapget}\PY{p}{(}\PY{n}{L}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n}{L}\PY{p}{:}
        \PY{k}{if} \PY{n}{e}\PY{o}{.}\PY{n}{key} \PY{o}{==} \PY{n}{key}\PY{p}{:}
            \PY{k}{return} \PY{n}{e}\PY{o}{.}\PY{n}{value}
    \PY{k}{raise} \PY{n+ne}{KeyError}
\end{Verbatim}



\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{m} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{n}{mapput}\PY{p}{(}\PY{n}{m}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{five}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{mapput}\PY{p}{(}\PY{n}{m}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{one}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{mapput}\PY{p}{(}\PY{n}{m}\PY{p}{,} \PY{l+m+mi}{13}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{thirteen}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{mapput}\PY{p}{(}\PY{n}{m}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{four}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{k}{assert}\PY{p}{(}\PY{n}{mapget}\PY{p}{(}\PY{n}{m}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{one}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{k}{assert}\PY{p}{(}\PY{n}{mapget}\PY{p}{(}\PY{n}{m}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{)} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{four}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

\begin{Verbatim}
\end{Verbatim}


At this point, it seems that the only advantage of the \texttt{dict} structure is that it provides some useful syntax for adding and getting entries.  There are some other advantages, but we'll only reveal them by trying to build a map ourselves.


First, let's put our new data structure in a class.  This will allow us to encapsulate the underlying list so that users don't accidentally mess it up, for example, by appending to it rather than using \texttt{put}.  We'd like to protect users from themselves, especially when there are properties of the structure we want to maintain.  In this case, we want to make sure keys stay unique.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{mapping} \PY{k+kn}{import} \PY{n}{Entry}

\PY{k}{class} \PY{n+nc}{ListMappingSimple}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries} \PY{o}{=} \PY{p}{[}\PY{p}{]}

    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{p}{:}
            \PY{k}{if} \PY{n}{e}\PY{o}{.}\PY{n}{key} \PY{o}{==} \PY{n}{key}\PY{p}{:}
                \PY{n}{e}\PY{o}{.}\PY{n}{value} \PY{o}{=} \PY{n}{value}
                \PY{k}{return}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{Entry}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{get}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{p}{:}
            \PY{k}{if} \PY{n}{e}\PY{o}{.}\PY{n}{key} \PY{o}{==} \PY{n}{key}\PY{p}{:}
                \PY{k}{return} \PY{n}{e}\PY{o}{.}\PY{n}{value}
        \PY{k}{raise} \PY{n+ne}{KeyError}
\end{Verbatim}



This is an okay start.  It supports \texttt{get} and \texttt{put} and that's enough to be a mapping, but we'd like several more interesting methods to really put such a structure to use.  Let's extend the ADT with more features.

\section{The extended Mapping ADT}


As with any collection, we might want some other methods such as \texttt{\_\_len\_\_}, \texttt{\_\_contains\_\_}, or various iterators.  


The standard behavior for iterators in dictionaries is to iterate over the keys.  Alternative iterators are provided to iterate over the values or to iterate over the key-value pairs as tuples.  For a \texttt{dict} object this is done as follows.


\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{d} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{key1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{value1}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{key2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{value2}\PY{l+s+s1}{\PYZsq{}}\PY{p}{\PYZcb{}}

\PY{k}{for} \PY{n}{k} \PY{o+ow}{in} \PY{n}{d}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{k}\PY{p}{)}

\PY{k}{for} \PY{n}{v} \PY{o+ow}{in} \PY{n}{d}\PY{o}{.}\PY{n}{values}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{v}\PY{p}{)}

\PY{k}{for} \PY{n}{k}\PY{p}{,} \PY{n}{v} \PY{o+ow}{in} \PY{n}{d}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{k}\PY{p}{,} \PY{n}{v}\PY{p}{)}
\end{Verbatim}

\begin{Verbatim}
key1
key2
value1
value2
key1 value1
key2 value2
\end{Verbatim}


We'll add the same kind of functionality to our Mapping ADT.  So, the \textbf{extended Mapping ADT} includes the following methods (with get and put renamed for python magic).

\begin{itemize}

\item 

\texttt{\_\_getitem\_\_(k)}** - return the value associate to the key \texttt{k}.  Usually an error (\texttt{KeyError}) is raised if the given key is not present.



\item 

\texttt{\_\_setitem\_\_(k, v)} - Add the key-value pair \texttt{(k,v)} to the mapping.



\item 

\texttt{\_\_len\_\_} - return the number of keys in the dictionary.



\item 

\texttt{\_\_contains\_\_(k)} - return true if the mapping contains a pair with key \texttt{k}.



\item 

\texttt{\_\_iter\_\_} - return an iterator over the keys in the dictionary.



\item 

\texttt{values} - return an iterator over the values in the dictionary.



\item 

\texttt{items} - return an iterator over the key-value pairs (as tuples).



\item 

\texttt{\_\_str\_\_} - return a string representation of the mapping.



\end{itemize}

It is very important to recall from the very beginning of the course that the \texttt{dict} class is a \textbf{non-sequential collection}.  That is, there is no significance to the ordering of the items and furthermore, you should never assume to know anything about the ordering of the pairs.  You should not even assume that the ordering will be consistent between two iterations of the same \texttt{dict}.  This same warning goes for the mappings we will implement and we'll see that the ability to rearrange the order of how they are stored is the secret behind the mysteriously fast running times.  However, this first implementation will have the items in a fixed order because we are using a \texttt{list} to store them.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{mapping} \PY{k+kn}{import} \PY{n}{Entry}

\PY{k}{class} \PY{n+nc}{ListMapping}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries} \PY{o}{=} \PY{p}{[}\PY{p}{]}

    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{n}{e} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entry}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{if} \PY{n}{e} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
            \PY{n}{e}\PY{o}{.}\PY{n}{value} \PY{o}{=} \PY{n}{value}
        \PY{k}{else}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{Entry}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{get}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{n}{e} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entry}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{if} \PY{n}{e} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
            \PY{k}{return} \PY{n}{e}\PY{o}{.}\PY{n}{value}
        \PY{k}{else}\PY{p}{:}
            \PY{k}{raise} \PY{n+ne}{KeyError}

    \PY{k}{def} \PY{n+nf}{\PYZus{}entry}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{p}{:}
            \PY{k}{if} \PY{n}{e}\PY{o}{.}\PY{n}{key} \PY{o}{==} \PY{n}{key}\PY{p}{:}
                \PY{k}{return} \PY{n}{e}
        \PY{k}{return} \PY{k+kc}{None}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{, }\PY{l+s+s2}{\PYZdq{}}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n+nb}{str}\PY{p}{(}\PY{n}{e}\PY{p}{)} \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}len\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{p}{)}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}contains\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}    
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entry}\PY{p}{(}\PY{n}{key}\PY{p}{)} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
            \PY{k}{return} \PY{k+kc}{False}
        \PY{k}{else}\PY{p}{:}
            \PY{k}{return} \PY{k+kc}{True}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}iter\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
      \PY{k}{return} \PY{p}{(}\PY{n}{e}\PY{o}{.}\PY{n}{key} \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{values}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{p}{(}\PY{n}{e}\PY{o}{.}\PY{n}{value} \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{items}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{p}{(}\PY{p}{(}\PY{n}{e}\PY{o}{.}\PY{n}{key}\PY{p}{,} \PY{n}{e}\PY{o}{.}\PY{n}{value}\PY{p}{)} \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{p}{)}

    \PY{n+nf+fm}{\PYZus{}\PYZus{}getitem\PYZus{}\PYZus{}} \PY{o}{=} \PY{n}{get}
    \PY{n+nf+fm}{\PYZus{}\PYZus{}setitem\PYZus{}\PYZus{}} \PY{o}{=} \PY{n}{put}
\end{Verbatim}



Note that I took the opportunity to factor out some duplication in the \texttt{get} and \texttt{put} methods.

\section{It's Too Slow!}


Our goal is to to get the same kind of constant-time operations as in the \texttt{dict} class.  Right now, we are very far from that.  Currently, we need linear time to \texttt{get}, \texttt{put}, and check membership.  To do better, we're going to need a new idea.  The \texttt{ListMapping} takes linear time because it has to iterate through the list.  We could make this faster if we had many short lists instead of one large list.  Then, we just need to have a quick way of knowing which short list to search or update.  


We're going to store a list of \texttt{ListMappings}.
For any key \texttt{k},  we want to compute the index of the \emph{right} \texttt{ListMapping} for \texttt{k}.  We often call these \texttt{ListMapping}s \emph{buckets}.  This term goes back to the idea that you can quickly group items into buckets.  Then, when looking for something in a bucket, you can check all the items in there assuming there arenâ€™t too many.


This means, we want an integer, i.e. the index into our list of buckets.  A \textbf{hash function} takes a key and returns an integer.  Most classes in python implement a method called \texttt{\_\_hash\_\_} that does just this.  We can use it to implement a simple mapping scheme that improves on the \texttt{ListMapping}.  

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{mapping} \PY{k+kn}{import} \PY{n}{ListMapping}

\PY{k}{class} \PY{n+nc}{HashMappingSimple}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{100}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets} \PY{o}{=} \PY{p}{[}\PY{n}{ListMapping}\PY{p}{(}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size}\PY{p}{)}\PY{p}{]}

    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{n}{m} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}bucket}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{n}{m}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n}{value}

    \PY{k}{def} \PY{n+nf}{get}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{n}{m} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}bucket}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{return} \PY{n}{m}\PY{p}{[}\PY{n}{key}\PY{p}{]}

    \PY{k}{def} \PY{n+nf}{\PYZus{}bucket}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets}\PY{p}{[}\PY{n+nb}{hash}\PY{p}{(}\PY{n}{key}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size}\PY{p}{]}
\end{Verbatim}



Let's look more closely at this code.  It seems quite simple, but it hides some mysteries.


First, the initializer creates a list of 100 ListMaps.  These are called the buckets. If the keys get spread evenly between the buckets then this will be about 100 times faster!  If two keys are placed in the same bucket, this is called a \textbf{collision}.


The \texttt{\_\_getitem\_\_} and \texttt{\_\_setitem\_\_} methods call the \texttt{\_bucket} method to get one of these buckets for the given key and then just use that ListMap's get and put methods.  So, the idea is just to have several list maps instead of one and then you just need a quick way to decide which to use.  The \texttt{hash} function returns an integer based on the value of the given key.  The collisions will depend on the hash function.

\subsection{How many buckets should we use?}


The number 100 is pretty arbitrary.  If there are many many entries, then one might get 100-fold speedup over ListMap, but not more.  Take a moment to marvel at how greedy we can be: \emph{only a 100x speedup?}


It makes sense to use more buckets as the number of entries increases.  To do this, we will keep track of the number of entries in the map.  This will allow us to implement \texttt{\_\_len\_\_} and also grow the number of buckets as needed.  As the number of entries grows, we can periodically increase the number of buckets.  Here is the code.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{mapping} \PY{k+kn}{import} \PY{n}{Entry}\PY{p}{,} \PY{n}{ListMapping}

\PY{k}{class} \PY{n+nc}{HashMapping}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{size} \PY{o}{=} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size} \PY{o}{=} \PY{n}{size}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets} \PY{o}{=} \PY{p}{[}\PY{n}{ListMapping}\PY{p}{(}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size}\PY{p}{)}\PY{p}{]}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length} \PY{o}{=} \PY{l+m+mi}{0}

    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{n}{m} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}bucket}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{if} \PY{n}{key} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{m}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
        \PY{n}{m}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n}{value}

        \PY{c+c1}{\PYZsh{} Check if we need more buckets.}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length} \PY{o}{\PYZgt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}double}\PY{p}{(}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{get}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{n}{m} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}bucket}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{return} \PY{n}{m}\PY{p}{[}\PY{n}{key}\PY{p}{]}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}contains\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{n}{m} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}bucket}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{return} \PY{n}{key} \PY{o+ow}{in} \PY{n}{m}

    \PY{k}{def} \PY{n+nf}{\PYZus{}bucket}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets}\PY{p}{[}\PY{n+nb}{hash}\PY{p}{(}\PY{n}{key}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size}\PY{p}{]}

    \PY{k}{def} \PY{n+nf}{\PYZus{}double}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} Save a reference to the old buckets.}
        \PY{n}{oldbuckets} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets}
        \PY{c+c1}{\PYZsh{} Double the size.}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size} \PY{o}{*}\PY{o}{=} \PY{l+m+mi}{2}
        \PY{c+c1}{\PYZsh{} Create new buckets}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets} \PY{o}{=} \PY{p}{[}\PY{n}{ListMapping}\PY{p}{(}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size}\PY{p}{)}\PY{p}{]}
        \PY{c+c1}{\PYZsh{} Add in all the old entries.}
        \PY{k}{for} \PY{n}{bucket} \PY{o+ow}{in} \PY{n}{oldbuckets}\PY{p}{:}
            \PY{k}{for} \PY{n}{key}\PY{p}{,} \PY{n}{value} \PY{o+ow}{in} \PY{n}{bucket}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
                \PY{c+c1}{\PYZsh{} Identify the new bucket.}
                \PY{n}{m} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}bucket}\PY{p}{(}\PY{n}{key}\PY{p}{)}
                \PY{n}{m}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n}{value}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}len\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}iter\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{b} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets}\PY{p}{:}
            \PY{k}{for} \PY{n}{k} \PY{o+ow}{in} \PY{n}{b}\PY{p}{:}
                \PY{k}{yield} \PY{n}{k}

    \PY{k}{def} \PY{n+nf}{values}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{b} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets}\PY{p}{:}
            \PY{k}{for} \PY{n}{v} \PY{o+ow}{in} \PY{n}{b}\PY{o}{.}\PY{n}{values}\PY{p}{(}\PY{p}{)}\PY{p}{:}
                \PY{k}{yield} \PY{n}{v}

    \PY{k}{def} \PY{n+nf}{items}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{b} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets}\PY{p}{:}
            \PY{k}{for} \PY{n}{k}\PY{p}{,} \PY{n}{v} \PY{o+ow}{in} \PY{n}{b}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
                \PY{k}{yield} \PY{n}{k}\PY{p}{,} \PY{n}{v}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} The following line is dangerous. It accesses a private attribute.}
        \PY{c+c1}{\PYZsh{} Thankfully, this will get factored out soon.}
        \PY{n}{itemlist} \PY{o}{=} \PY{p}{[}\PY{n+nb}{str}\PY{p}{(}\PY{n}{e}\PY{p}{)} \PY{k}{for} \PY{n}{b} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets} \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n}{b}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{p}{]}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{, }\PY{l+s+s2}{\PYZdq{}}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n}{itemlist}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}

    \PY{n+nf+fm}{\PYZus{}\PYZus{}getitem\PYZus{}\PYZus{}} \PY{o}{=} \PY{n}{get}
    \PY{n+nf+fm}{\PYZus{}\PYZus{}setitem\PYZus{}\PYZus{}} \PY{o}{=} \PY{n}{put}
\end{Verbatim}


\subsection{Rehashing}


The most interesting part of the code above is the \texttt{\_double} method.  This is a method that increases the number of buckets.  It's not enough to just append more buckets to the list, because the \texttt{\_bucket} method that we use to find the right bucket depends on the number of buckets.  When that number changes, we have to reinsert all the items in the mapping so that they can be found when we next \texttt{get} them.  

\section{Factoring Out A Superclass}


We have given two different implementations of the same ADT.  There are several methods that we implemented in the \texttt{ListMapping} that we will also want in the \texttt{HashMapping}.  It makes sense to avoid duplicating common parts of these two (concrete) data structures.  Inheritance provides a nice way to do this.


This is the most common way that inheritance appears in code.  Two classes want to share some code, so we \textbf{factor out a superclass} that both can inherit from and share the underlying code.


There are some methods that we expect to be implemented by the subclass.  We can enforce this by putting the methods in the subclass, but raising an error if they are called.   This way, the error will only be raised if the subclass does not override those methods.


Here is the code for the superclass.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{Mapping}\PY{p}{:}

    \PY{c+c1}{\PYZsh{} Child class needs to implement this!}
    \PY{k}{def} \PY{n+nf}{get}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{k}{raise} \PY{n+ne}{NotImplementedError}

    \PY{c+c1}{\PYZsh{} Child class needs to implement this!}
    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{k}{raise} \PY{n+ne}{NotImplementedError}

    \PY{c+c1}{\PYZsh{} Child class needs to implement this!}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}len\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{raise} \PY{n+ne}{NotImplementedError}

    \PY{c+c1}{\PYZsh{} Child class needs to implement this!}
    \PY{k}{def} \PY{n+nf}{\PYZus{}entryiter}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{raise} \PY{n+ne}{NotImplementedError}   

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}iter\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
      \PY{k}{return} \PY{p}{(}\PY{n}{e}\PY{o}{.}\PY{n}{key} \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entryiter}\PY{p}{(}\PY{p}{)}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{values}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{p}{(}\PY{n}{e}\PY{o}{.}\PY{n}{value} \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entryiter}\PY{p}{(}\PY{p}{)}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{items}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{p}{(}\PY{p}{(}\PY{n}{e}\PY{o}{.}\PY{n}{key}\PY{p}{,} \PY{n}{e}\PY{o}{.}\PY{n}{value}\PY{p}{)} \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entryiter}\PY{p}{(}\PY{p}{)}\PY{p}{)}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}contains\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{k}{try}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{except} \PY{n+ne}{KeyError}\PY{p}{:}
            \PY{k}{return} \PY{k+kc}{False}
        \PY{k}{return} \PY{k+kc}{True}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}getitem\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{key}\PY{p}{)}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}setitem\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{put}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}str\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZob{}}\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{, }\PY{l+s+s2}{\PYZdq{}}\PY{o}{.}\PY{n}{join}\PY{p}{(}\PY{n+nb}{str}\PY{p}{(}\PY{n}{e}\PY{p}{)} \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entryiter}\PY{p}{(}\PY{p}{)}\PY{p}{)} \PY{o}{+} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}



There is a lot here, but notice that there are really only four methods that a subclass has to implement: \texttt{get}, \texttt{put}, \texttt{\_\_len\_\_}, and a method called \texttt{\_entryiter} that iterates through the entries.  This last method is private because the user of this class does not need to access \texttt{Entry} objects.  They have the Mapping ADT methods to provide access to the data.  This is why the \texttt{Entry} class is an inner class (defined inside the \texttt{Mapping} class).


Now, the \texttt{ListMapping} can be rewritten as follows.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{mapping} \PY{k+kn}{import} \PY{n}{Mapping}\PY{p}{,} \PY{n}{Entry}

\PY{k}{class} \PY{n+nc}{ListMapping}\PY{p}{(}\PY{n}{Mapping}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries} \PY{o}{=} \PY{p}{[}\PY{p}{]}

    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{n}{e} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entry}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{if} \PY{n}{e} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
            \PY{n}{e}\PY{o}{.}\PY{n}{value} \PY{o}{=} \PY{n}{value}
        \PY{k}{else}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{Entry}\PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{get}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{n}{e} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entry}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{if} \PY{n}{e} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
            \PY{k}{return} \PY{n}{e}\PY{o}{.}\PY{n}{value}
        \PY{k}{else}\PY{p}{:}
            \PY{k}{raise} \PY{n+ne}{KeyError}

    \PY{k}{def} \PY{n+nf}{\PYZus{}entry}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{p}{:}
            \PY{k}{if} \PY{n}{e}\PY{o}{.}\PY{n}{key} \PY{o}{==} \PY{n}{key}\PY{p}{:}
                \PY{k}{return} \PY{n}{e}
        \PY{k}{return} \PY{k+kc}{None}

    \PY{k}{def} \PY{n+nf}{\PYZus{}entryiter}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb}{iter}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{p}{)}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}len\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}entries}\PY{p}{)}
\end{Verbatim}



All the magic methods as well as the public iterators and string conversion are handled by the superclass.  The subclass only has the parts that are specific to this implementation.


The \texttt{HashMapping} class can also be rewritten as follows.

\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{ds2}\PY{n+nn}{.}\PY{n+nn}{mapping} \PY{k+kn}{import} \PY{n}{Mapping}\PY{p}{,} \PY{n}{ListMapping}

\PY{k}{class} \PY{n+nc}{HashMapping}\PY{p}{(}\PY{n}{Mapping}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{size} \PY{o}{=} \PY{l+m+mi}{100}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size} \PY{o}{=} \PY{n}{size}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets} \PY{o}{=} \PY{p}{[}\PY{n}{ListMapping}\PY{p}{(}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size}\PY{p}{)}\PY{p}{]}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length} \PY{o}{=} \PY{l+m+mi}{0}

    \PY{k}{def} \PY{n+nf}{\PYZus{}entryiter}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{p}{(}\PY{n}{e} \PY{k}{for} \PY{n}{bucket} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets} \PY{k}{for} \PY{n}{e} \PY{o+ow}{in} \PY{n}{bucket}\PY{o}{.}\PY{n}{\PYZus{}entryiter}\PY{p}{(}\PY{p}{)}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{get}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{n}{bucket} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}bucket}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{return} \PY{n}{bucket}\PY{p}{[}\PY{n}{key}\PY{p}{]}

    \PY{k}{def} \PY{n+nf}{put}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)}\PY{p}{:}
        \PY{n}{bucket} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}bucket}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{if} \PY{n}{key} \PY{o+ow}{not} \PY{o+ow}{in} \PY{n}{bucket}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
        \PY{n}{bucket}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n}{value}

        \PY{c+c1}{\PYZsh{} Check if we need more buckets.}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length} \PY{o}{\PYZgt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}double}\PY{p}{(}\PY{p}{)}

    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}len\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}length}

    \PY{k}{def} \PY{n+nf}{\PYZus{}bucket}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{key}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets}\PY{p}{[}\PY{n+nb}{hash}\PY{p}{(}\PY{n}{key}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size}\PY{p}{]}

    \PY{k}{def} \PY{n+nf}{\PYZus{}double}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{c+c1}{\PYZsh{} Save the old buckets}
        \PY{n}{oldbuckets} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}buckets}
        \PY{c+c1}{\PYZsh{} Reinitialize with more buckets.}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{\PYZus{}size} \PY{o}{*} \PY{l+m+mi}{2}\PY{p}{)}
        \PY{k}{for} \PY{n}{bucket} \PY{o+ow}{in} \PY{n}{oldbuckets}\PY{p}{:}
            \PY{k}{for} \PY{n}{key}\PY{p}{,} \PY{n}{value} \PY{o+ow}{in} \PY{n}{bucket}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n}{value}
\end{Verbatim}
